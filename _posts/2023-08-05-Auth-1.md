---
title: "Spring Security로 구현하는 인증/인가 (1)"
excerpt: "UsernamePasswordAuthenticationFilter을 이용해 인증 로직을 구현하자"

categories:
  - 자바&코틀린하린

permalink: /자바&코틀린하린/Auth-1/

toc: true
toc_sticky: true

date: 2023-08-05
last_modified_at: 2023-08-05
---

  

## Authentication VS Authorization
spring cloud security로 구현하는 인증/인가의 방법을 알아보기 전에 Authentication(인증)과 Authorization(인가)의 차이에 대해 먼저 알아봅시다.

### Authentication(인증) 
`인증은 로그인과 같이 사용자 또는 프로세스의 신원을 확인하는 프로세스`
인증은 사용자가 자신이 주장하는 신원을 확인하는 프로세스를 의미합니다. 시스템은 사용자가 누구인지 확인하기 위해 제공한 자격 증명(예: 아이디와 비밀번호, 지문, 인증서 등)을 검증합니다. 이로 인해 시스템은 사용자의 신분을 확인하고, 해당 사용자가 자신이 주장하는 것과 일치하는지 확인할 수 있습니다. 인증이 성공적으로 이루어지면 사용자는 시스템에 접근할 수 있는 권한이 주어집니다.

### Authorization(인가)
`인가는 누가 무엇을 할 수 있는지 결정하는 규칙`
인가는 인증된 사용자에게 시스템의 특정 자원이나 서비스에 접근할 수 있는 권한을 부여하는 과정입니다. 인증 단계에서 확인된 사용자의 신분에 따라 시스템은 해당 사용자에게 필요한 자원에 대한 권한을 제공합니다. 인증이 성공적으로 이루어진 경우에만 인가가 이루어집니다.


## Spring Security
![enter image description here](https://github.com/rineeee/rineeee.github.io/blob/main/assets/images/auth.jpg?raw=true)
`UsernamePasswordAuthenticationFilter`를 이용해 간단한 인증 로직을 구현할 수 있습니다.  이번에는 authenticationFilter의 attemptAuthentication과 successAuthentication을 구현해 보도록하겠습니다.

1. 인증 로직을 구현할 클래스에 `UsernamePasswordAuthenticationFilter`를 상속받습니다.
2. `attemptAuthentication`를 override 후 구현합니다. 인증을 시도할 때 자신이 원하는 작업을 커스터마이징 시킬 수 있습니다.
3. `successfulAuthentication`를 override 후 구현합니다. 인증이 성공했을 때 자신이 원하는 작업을 커스터마이징 시킬 수 있습니다.

본 예시는 Username을 email로 사용합니다.

### Authentication(인증) 
#### attemptAuthentication

    @Override  
	public Authentication attemptAuthentication(HttpServletRequest request,  
	  HttpServletResponse response) throws AuthenticationException {  
	  try {  
	        RequestLogin creds = new ObjectMapper().readValue(request.getInputStream(), RequestLogin.class);  
	  
	 return getAuthenticationManager().authenticate(  
	                new UsernamePasswordAuthenticationToken(  
	                        creds.getEmail(),  
	  creds.getPassword(),  
	 new ArrayList<>()  
	                )  
	        );  
	  } catch (IOException e){  
	        throw new RuntimeException(e);  
	  }  
	}


#### successfulAuthentication

    @Override  
	protected void successfulAuthentication(HttpServletRequest request,  
	  HttpServletResponse response,  
	  FilterChain chain,  
	  Authentication authResult) throws IOException, ServletException {  
	    String userName = ((User)authResult.getPrincipal()).getUsername();  
	  UserDto userDetails = userService.getUserDetailsByEmail(userName);  
	  
	  // jwt 생성
	  String token = Jwts.builder()  
	            .setSubject(userDetails.getUserId())  
	            .setExpiration(new Date(System.currentTimeMillis() +  
	                    Long.parseLong(env.getProperty("token.expiration_time"))))  
	            .signWith(SignatureAlgorithm.HS512, env.getProperty("token.secret"))  
	            .compact();  
	  
	  response.addHeader("token", token);  
	  response.addHeader("userId",userDetails.getUserId());  
	}

참고:
[UsernamePasswordAuthenticationFilter](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/UsernamePasswordAuthenticationFilter.html)
